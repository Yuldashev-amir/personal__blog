'use strict';

var utils = require('./utils');

/**
 * Emit an empty string to effectively "skip" the string for the given `node`,
 * but still emit the position and node type.
 *
 * ```js
 * // do nothing for beginning-of-string
 * snapdragon.compiler.set('bos', utils.noop);
 * ```
 * @param {Object} node
 * @api public
 */

exports.noop = function(node) {
  this.emit('', node);
};

/**
 * Emit an empty string to effectively "skip" the string for the given `node`,
 * but still emit the position and node type.
 *
 * ```js
 * snapdragon.compiler
 *   .set('i', function(node) {
 *     this.mapVisit(node);
 *   })
 *   .set('i.open', utils.emit('<i>'))
 *   .set('i.close', utils.emit('</i>'))
 * ```
 * @param {Object} node
 * @api public
 */

exports.emit = function(val) {
  return function(node) {
    this.emit(val, node);
  };
};

/**
 * Converts an AST node into an empty `text` node and delete `node.nodes`.
 *
 * ```js
 * utils.toNoop(node);
 * utils.toNoop(node, true); // convert `node.nodes` to an empty array
 * ```
 * @param {Object} `node`
 * @api public
 */

exports.toNoop = function(node, keepNodes) {
  if (keepNodes === true) {
    node.nodes = [];
  } else {
    delete node.nodes;
  }
  node.type = 'text';
  node.val = '';
};

/**
 * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon
 * automatically calls registered compilers, this allows you to pass a visitor
 * function.
 *
 * ```js
 * snapdragon.compiler
 *   .set('i', function(node) {
 *     exports.visit(node, function(node2) {
 *       // do stuff with "node2"
 *       return node2;
 *     });
 *   })
 * ```
 * @param {Object} `node`
 * @param {Function} `fn`
 * @return {Object} returns the node
 * @api public
 */

exports.visit = function(node, options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = {};
  }

  if (utils.typeOf(node) !== 'object') {
    throw new TypeError('expected node to be an object');
  }
  if (utils.typeOf(fn) !== 'function') {
    throw new TypeError('expected visitor to be a function');
  }

  node = fn(node) || node;
  var nodes = node.nodes || node.children;
  if (options && options.recurse && Array.isArray(nodes)) {
    exports.mapVisit(node, options, fn);
  }
  return node;
};

/**
 * Map [visit](#visit) with the given `fn` over an array of AST `nodes`.
 *
 * ```js
 * snapdragon.compiler
 *   .set('i', function(node) {
 *     exports.mapVisit(node, function(node2) {
 *       // do stuff with "node2"
 *       return node2;
 *     });
 *   })
 * ```
 * @api public
 */

exports.mapVisit = function(parent, options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = {};
  }

  var nodes = parent.nodes || parent.children;
  if (!Array.isArray(nodes)) {
    throw new TypeError('.mapVisit: exected parent.nodes to be an array');
  }

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    utils.define(node, 'parent', parent);
    nodes[i] = exports.visit(node, options, fn) || node;

    // reset properties on `nodes[i]` in case the returned
    // node was user-defined and the properties were lost
    utils.define(nodes[i], 'parent', parent);
  }
  return node;
};

/**
 * Wrap the given `node` with `*.open` and `*.close` tags.
 *
 * @param {Object} `node`
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {undefined}
 * @api public
 */

exports.wrapNodes = function(node, filter) {
  exports.addOpen(node, filter);
  exports.addClose(node, filter);
};

/**
 * Unshift an `*.open` node onto `node.nodes`.
 *
 * @param {Object} `node`
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {undefined}
 * @api public
 */

exports.addOpen = function(node, filter) {
  if (typeof filter === 'function' && !filter(node)) return;
  var open = new utils.Node({ type: node.type + '.open', val: ''});
  if (node.isNode && node.pushNode) {
    node.unshiftNode(open);
  } else {
    exports.unshiftNode(node, open);
  }
};

/**
 * Push a `*.close` node onto `node.nodes`.
 *
 * @param {Object} `node`
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {undefined}
 * @api public
 */

exports.addClose = function(node, filter) {
  if (typeof filter === 'function' && !filter(node)) return;
  var close = new utils.Node({ type: node.type + '.close', val: ''});
  if (node.isNode && node.pushNode) {
    node.pushNode(close);
  } else {
    exports.pushNode(node, close);
  }
};

/**
 * Push `node` onto `parent.nodes`.
 *
 * ```js
 * var parent = new Node({type: 'foo'});
 * var node = new Node({type: 'bar'});
 * utils.pushNode(parent, node);
 * console.log(parent.nodes[0].type) // 'bar'
 * ```
 * @param {Object} `node`
 * @param {Function} `filter` Optionaly specify a filter function to exclude the node.
 * @return {undefined}
 * @api public
 */

exports.pushNode = function(parent, node) {
  parent.nodes = parent.nodes || [];
  node.define('parent', parent);
  parent.nodes.push(node);
};

/**
 * Unshift `node` onto `parent.nodes`.
 *
 * ```js
